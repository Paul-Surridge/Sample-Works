Spring

	XML Configuration:

		- XML Configuration individual files represents/defines a logical layer or module in overall architecture.

	Purpose:

		- XML Configuration files defines the following:

			1. Beans:		The beans that are to be contained within the container
			2. Wiring:		How the beans within the container depend or are wired into each other.
			3. Instantiation:	How the beans within the container are instantiated i.e. what other beans/dependencies do they require in order to be instantiated.
			4. Injection:		How the beans within the container are injected with instances/dependencies of other beans that need/use them in order to be instantiated.
			5. Structure:		Provide a skeletal structure of the beans that are contained withn the container.

		- XML Configuration files do not define the actual implementation but only aspects necessary for the beans to be managed by the container e.g.

			1. ID
			2. Names/Alias
			3. Scope
			4. Location of package/class containing implementation
			5. Dependencies of the individual beans i.e. the additional local beans that need to be injected into class (how they are wired together).

	General Form:

		- XML Configuration has the following general form:

			<beans [Header]

				<bean ...>
				    ...		//Bean 1
				</bean>

				<bean ...>
				    ...		//Bean 2
				</bean>

				<bean ...>
				    ...		//Bean 3
				</bean>

			</beans>

		- XML Configuration has the following general components:

			<beans 	xmlns="http://www.springframework.org/schema/beans"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				xsi:schemaLocation="http://www.springframework.org/schema/beans
				https://www.springframework.org/schema/beans/spring-beans.xsd">

				<bean id="myBean1" class="fully.qualified.package">  
				    ...														<!-- Additional collaborators and configuration for bean -->
				</bean>

				<bean id="myBean2" class="fully.qualified.package">
				    ...
				</bean>

				...

				<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">			<!-- Service Bean -->
					<property name="accountDao" ref="accountDao"/>
					<property name="itemDao" ref="itemDao"/>
				    ...														<!-- Additional collaborators and configuration for bean -->
				</bean>

				<bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">			<!-- DAO Data Access Object Bean -->
				    ...														<!-- Additional collaborators and configuration for bean -->
				</bean>

				<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">				<!-- DAO Data Access Object Bean -->
				    ...														<!-- Additional collaborators and configuration for bean -->
				</bean>

			</beans>

	<bean/>:

		- XML Configuration file utilise the <bean/> element to define beans contained within the container:

			Element:	Attribute		Defines
			-----------------------------------------------------------------------------------------------------------------------------
			<bean		id			String identifies individual bean definition.

					name			Alias used in addition to id.

					class			Type of bean.
								Location of class that is to instantiate bean using fully qualified package and class name.
								Corresponds/sets to the stored Class property in the BeanDefinition object.
								Usually mandatory except when using an Instance Factory Method or Bean Inhertitance.

					constructor-arg		Type of instance to be generated by container and passed/injected into constructor method argument

					property		Type of instance to be generated by container and passed/injected into setter method argument

	Bean Instantiation + Return - Examples:

		- XML Configuration definition of beans and how they correspond within the source code:

			1. via *.xml + Constructor(No Dependencies) (JavaBeans)

				[XML Config]

					<bean id="ClassA" class="com.MyApplication.ClassA"/>			//No argument constructor ('raw JavaBean style')
					<bean name="ClassB" class="com.MyApplication.ClassB"/>

				[Source Code]

					package com.myApplication;

					class ClassA
					{
					    public ClassA()
					    {
						...
					    }
					}

					class ClassB
					{
					    public ClassB()
					    {
						...
					    }
					}

				Here:

					1. Container reads the XML file as there being:

						"Only x2 beans in container"
						"Both beans are instantiated and obtained/returned via their no-argument constructors found at 'com.MyApplication.ClassA' and 'com.MyApplication.ClassB'"

			2. via *.xml + Constructor(x2 Dependencies) (No Ambiguities)

				[XML Config]

					<beans>
					    <bean id="classA" class="com.myApplication.ClassA">
						<constructor-arg ref="classB"/>
						<constructor-arg ref="classC"/>
					    </bean>

					    <bean id="classB" class="com.myApplication.ClassB"/>
					    <bean id="classC" class="com.myApplication.ClassC"/>
					</beans>

				[Source Code]

					package com.myApplication;

					class ClassA
					{
					    private final ClassB objClassB;
					    private final ClassC objClassC;
	
					    public ClassA(ClassB objClassB, ClassC objClassC)
					    {
						this.objClassB = objClassB;
						this.objClassC = objClassC;
					    }
					}

				Here:
					1. Container reads the XML file as there being:

						"x3 beans found at 'com.MyApplication.ClassA', 'com.MyApplication.ClassB' and 'com.MyApplication.ClassC'"
						"ClassA needs to be supplied with an instance of ClassB and ClassC to be passed as arguments to its constructor"

					2. ClassB and ClassC are not related (via inheritence) and unambiguous therefore the container can inject them in order as shown from left to right.

			3. via *.xml + Constructor(x2 Dependencies) (With Ambiguities)

				If there is ambiguity then additional clarity will be needed via attributes e.g. 'type', 'index' or 'name'

				[XML Config]

					<bean id="classA" class="com.myApplication.ClassA">
					    <constructor-arg type="int" value="7500000"/>
					    <constructor-arg type="java.lang.String" value="Period of time:"/>
					</bean>

					[Or]

					<bean id="classB" class="com.myApplication.ClassA">
					    <constructor-arg index="0" value="7500000"/>
					    <constructor-arg index="1" value="Period of time:"/>
					</bean>

					[Or]

					<bean id="classB" class="com.myApplication.ClassA">
					    <constructor-arg name="iYears" value="7500000"/>
					    <constructor-arg name="sDescription" value="Period of time:"/>		
					</bean>

				[Source Code]

					class ClassA
					{
					    private final int iYears;
					    private final String sDescription;
	
					    public ClassA(int iYears, String sDescription)
					    {
					    	this.iYears = iYears;
						this.sDescription = sDescription;
					    }
					}

					Here:
						1. Providing the additional attributes in XML configuration allows the container to determine what the bean arguments are, how they should be interpreted and injected.
						2. Code must be compiled with Debug flag enabled if using the 'name' attribute so that container can lookup name, if not wish to enable flag then use @ConstructorProperties() below:

						class ClassA
						{
						    @ConstructorProperties({"iYears", "sDescription"})
						    public ClassA(int iYears, String sDescription)
						    {
							this.iYears = iYears;
							this.sDescription = sDescription;
						    }
						}

			3. via *.xml + Constructor(x3 Dependencies: x2 Beans, x1 Primitive (Inline value))

				[XML Config]

					<bean id="houseBean" class="com.myApplication.HouseBean">
						<constructor-arg ref="doorBean"/>
						<constructor-arg ref="windowBean"/>
						<constructor-arg type="int" value="1"/>			<!-- value of the int is defined 'inline' and passed straight into the constructor-->
					</bean>

					<bean id="doorBean" class="com.myApplication.DoorBean"/>
					<bean id="windowBean" class="com.myApplication.WindowBean"/>

				[Source Code]

					public class HouseBean {

					    private DoorBean bean1;
					    private WindowBean bean2;
					    private int iHeight;

					    public HouseBean(DoorBean myDoorBean, WindowBean myWindowBean, int i) {
						this.bean1 = myDoorBean;
						this.bean2 = myWindowBean;
						this.iHeight = i;
					    }
					}

					Here:

						1. Given that the arguments are unambiguous and do not use 'name' attribute the corresponding paramters names can be given identifiers as seen fit.

			4. via *.xml + Static Factory Method(x3 Dependencies)

				[XML Config]

					<bean id="houseBean" class="com.myApplication.HouseBean" factory-method="createInstance">		<!-- introduce factory-method attribute -->
						<constructor-arg ref="doorBean"/>
						<constructor-arg ref="windowBean"/>
						<constructor-arg type="int" value="1"/>			<!-- value of the int is defined 'inline' and passed straight into the constructor-->
					</bean>

					<bean id="doorBean" class="com.myApplication.DoorBean"/>
					<bean id="windowBean" class="com.myApplication.WindowBean"/>

				[Source Code]

					public class HouseBean {

					    private HouseBean(...)										//Private Constructor
					    {...}

					    public static HouseBean createInstance(DoorBean myDoorBean, WindowBean myWindowBean, int i) {	//Instantiates, builds and returns necessary HouseBean bean
						HouseBean hb = new HouseBean(...);
						return hb;
					    }
					}

					Here:

						1. The static factory method returns the required bean (just as a constructor method would).
						2. The static factory method are passsed the same set of arguments as the constructor.
						3. The passed arguments are still considered the dependencies of the bean HouseBean regardless if they are used or not.

						NB: The instance that is returned by the static factory method does not need to be of the same class that contains this method.

			5. via *.xml + Instance Factory Method(No Dependencies)

				The same as above for static factory method except that the attribute 'factory-bean' is used instead of 'class'. Here the factory method is of an existing bean that already exists in the container:

				[XML Config]

					<bean id="serviceLocator" class="examples.DefaultServiceLocator"/>

					<bean id="clientService"
					    factory-bean="serviceLocator"
					    factory-method="createClientServiceInstance"/>

					<bean id="accountService"
					    factory-bean="serviceLocator"
					    factory-method="createAccountServiceInstance"/>

				[Source Code]

					public class DefaultServiceLocator {
					    private static ClientService clientService = new ClientServiceImpl();
					    private static AccountService accountService = new AccountServiceImpl();

					    public ClientService createClientServiceInstance() {
						return clientService;
					    }

					    public AccountService createAccountServiceInstance() {
						return accountService;
					    }
					}

	Bean Injection - Examples:

		- XML Configuration definition of beans and how they correspond within the source code:

			1. via *.xml + Setter Method(x3 Properties/Dependencies: x2 Object and x1 Int (Inline))

				[XML Config]

					<bean id="classA" class="com.MyAppication.ClassA">				
					    <property name="beanOne">				<!-- Setter injection using nested ref element -->
						<ref bean="classB"/>
					    </property>
										
					    <property name="beanTwo" ref="classC"/>		<!-- Setter injection using 'neater' ref attribute -->
					    <property name="integerProperty" value="1"/>
					</bean>

					<bean id="classB" class="com.MyAppication.ClassB"/>
					<bean id="classC" class="com.MyAppication.ClassC"/>

				[Source Code]

					public class ClassA {

					    private ClassB beanOne;
					    private ClassC beanTwo;
					    private int i;

					    public void setBeanOne(ClassB beanOne) {		//Method names are set<property name> in camel case
					    	this.beanOne = beanOne;
					    }

					    public void setBeanTwo(ClassC beanTwo) {
					    	this.beanTwo = beanTwo;
					    }

					    public void setIntegerProperty(int i) {
					    	this.i = i;
					    }
				    	}

	<bean/>

		- XML Configuration definitions of beans can generally be considered as follows:

			<bean id="houseBean"					// ID of this particular bean to be used within this xml file (not within source code)
			    class="com.myApplication.HouseBean">		// Location of the actual implementation source code for this bean

			    <constructor-arg ref="doorBean"/>			// Describes how to get an actual instance of the bean and what (if anything) needs to be passed into it's constructor 
			    <constructor-arg ref="windowBean"/>			// "
			    <constructor-arg type="int" value="1"/>		// "
			</bean>

		- XML Configuration bean definition describes the following aspects:

			1. ID:		Local ID for use within the XML configuration as referenced from within this current file or externally.
			2. Location:	Where the actual class *.java implementation can be found.
			3. Instance:	How an instance of the bean can be acquired from the *.java file in the supplied location e.g. via either it's:

						1. Constructor
						2. Setter
						3. Static factory method
						4. Instance factory method

			4. Arguments:	What (dependencies) need to be passed into the method (at stage 3 above) in order to generate and return an instance of the bean.

	Attribute: ref

		- XML Configuration definitions of beans make constant use of the attriute 'ref=', this is the id/name of the object/bean that is to be passed/injected/wired into the client bean.

	Constructor/Setter Injected Parameter Names

		- XML Configuration appears to indicate that the name of the parameters defined within a constructor/setter method do not matter (only the type matters). Unless the 'name' attribute is used within the XML element.

	Static Nested Beans

		- XML Configuration can declare/specify that a bean may have a static nested bean by setting the 'class' to a value containing the . or $:

			com.example.MyClass.MyStaticNestedClass
			com.example.MyClass$MyStaticNestedClass

			NB: Either the binary name or source name for the static nested class can be used.

	Element v Attribute Style:

		- XML Configuration may be defined using either 'attribute' or 'element' styling, both are equivalent and interpreted the same but are formatted differently:

			Attribute:	<bean id="clientService" class="examples.ClientService"	factory-method="createInstance"/>

			Element:	<bean>
					    <id>clientService</id>
					    <class>examples.ClientService</class>
					    <factory-method>createInstance<factory-method>
					</bean>

			Spring recommends using attribute style whenever possible

	Importing XML Files:

		- XML Configuration can be combined/concatented using <import/> element:

			<beans>
				<import resource="services.xml"/>
				<import resource="resources/messageSource.xml"/>
				<import resource="/resources/themeSource.xml"/>

				<bean id="bean1" class="..."/>
				<bean id="bean2" class="..."/>
			</beans>

			Here:

				1. Additional *.xml files are automatically imported when the overall *.xml is read in.
				2. The path is relative to the location of the overall *.xml:

					service.xml:		Located in same folder as overall *.xml
					messageSource.xml:	Located in folder 'resources' inside same folder as overall *.xml
					themeSource.xml:	Located in folder 'resources' inside same folder as overall *.xml

					NB: The leading / is ignored however it is best practice to not include.

				3. <import/> is provided via the namespace as defined in <beans/>.

					NB: XML Configuration files can contain configuration other than just bean definitions by using differing namespaces e.g. 'context' and 'util'.				  

		- XML Configuration files that are defined and imported must contain valid bean definitions and adhere to the Spring Schema.

	File Referencing:

		- XML Configuration files can (in addition to the above) be referenced using:

			1. Relative Parent Directories:

				Using a relative '../' path e.g

					Classpath URL:		classpath:../service.xml

				However this is not recommended for when runtime resolution runs it will choose the 'nearest' classpath root and look in its parent directory, which may be subject to change thereby not finding the services.xml 

			2. Fully Qualified:

					File URL:		file:C:/config/services.xml
					Classpath URL:		classpath:/config/services.xml

				However this is not recommended due to the coupling of the application to specific locations.

	File Placeholder:

		- XML Configuration files should ideally always be referenced indirectly e.g. using "${...}" placeholders which reference values conatined in separate/external property files and/or JVM system properties at runtime.

	Inline Values:

		- XML Configuration files may include the 'inline' definition for a primitive value i.e. where the value of an int is 'hardcoded' into the XML file and is passed straight into the receiving method (be that a constructor or factory method)

			<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>					<!-- results in a setDriverClassName(String s) call -->
			    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
			    <property name="username" value="root"/>
			    <property name="password" value="misterkaoli"/>
			</bean>

			NB: Corresponding setter method:

				public void setDriverClassName(String s) {		//Need to check/test whether having the parameter name set to 's' is okay or needs to be set to 'driverClassName'.
				    this.s = s;
				}

			NB: It is presumed that inline values can be contained in external/separate property location and pulled in as required.

	p-namespace:

		- p-namespace is a short-cut means to implement more concise XML instead of having to use multiple nested <property/> elements:
		- p-namespace is not defined in an external XML Schema Document (XSD file) but exists within the core of the Spring.
		- p-namespace still needs to be defined in header:

			xmlns:p="http://www.springframework.org/schema/p"

			<beans xmlns="http://www.springframework.org/schema/beans"
			    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			    xmlns:p="http://www.springframework.org/schema/p"
			    xsi:schemaLocation="http://www.springframework.org/schema/beans
			    https://www.springframework.org/schema/beans/spring-beans.xsd">

			    ...
			</beans>

		- p-namespace examples:

			<bean name="classic" class="com.example.ExampleBean">
			    <property name="email" value="someone@somewhere.com"/>
			</bean>

			[Using p-namespace]

				<bean name="p-namespace" class="com.example.ExampleBean"
			    	    p:email="someone@somewhere.com"/>

				NB: p-namespace does not have a schema definition, so the name of the attribute can be set to the property name i.e. "email" can be used in the actual attribute 'p:email='

			-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			<bean name="john-classic" class="com.example.Person">
			    <property name="name" value="John Doe"/>
			    <property name="spouse" ref="jane"/>
			</bean>

			[Using p-namespace]

				<bean name="john-modern"
			    	    class="com.example.Person"
			    	    p:name="John Doe"				//Define String inline
			    	    p:spouse-ref="jane"/>			//Define other bean of name 'jane' using a trailing '-ref' i.e. 'p:spouse-ref'

				<bean name="jane" class="com.example.Person">
			    	    <property name="name" value="Jane Doe"/>
				</bean>

				NB: p.namespace can reference either inline values or other beans using a trailing '-ref'.

			-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
			    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
			    <property name="username" value="root"/>
			    <property name="password" value="misterkaoli"/>
			</bean>

			[Using p-namespace]

				<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
			    	    destroy-method="close"
			    	    p:driverClassName="com.mysql.jdbc.Driver"
			    	    p:url="jdbc:mysql://localhost:3306/mydb"
			    	    p:username="root"
			    	    p:password="misterkaoli"/>

			NB: Spring supports extending the formats permissible with XML using namespaces which are based on XML Schema definition

		- p-namespace should be used with caution:

			- p-namespace is not as flexible as the standard XML format.
			- The format for declaring property references clashes with properties that end in 'Ref' (whereas standard XML format does not).
			- Consideration and communication within team should avoid producing XML documents that use all three approaches at same time.

	c-namespace:

		- c-namepsace is a mirror of p-namespace but for <constructor-arg/> instead of <property/>.
		- c-namespace is a short-cut means to implement more concise XML instead of having to use multiple nested <constructor-arg/> elements:

			xmlns:c="http://www.springframework.org/schema/c"

		- c-namespace examples:

			<bean id="classB" class="com.MyApplication.ClassB"/>
			<bean id="classC" class="com.MyApplication.ClassC"/>

			<bean id="classA" class="com.MyApplication.ClassA">
			    <constructor-arg name="myClassB" ref="classB"/>
			    <constructor-arg name="myClassC" ref="classC"/>
			    <constructor-arg name="myEmail" value="something@somewhere.com"/>
			</bean>

			[Using c-namespace]

				<bean id="classA" class="com.MyApplication.ClassA" c:myClassB-ref="classB"
				    c:myClassC-ref="classC" c:myEmail="something@somewhere.com"/>

			[Using c-namespace - With indexing]

				 <bean id="classA" class="com.MyApplication.ClassA" c:_0-ref="classB" c:_1-ref="classC"
				    c:_2="something@somewhere.com"/>

				NB: Use the _0, _1 ... to index constructors if required (the _ is needed as XML attribute names cannot start with _. But recommended to use name notation.
				NB: The use of indexing may be required if the constructor names are not available e.g. if compiled without debugging information.

	Compound Property Names:

		- Compound Property Names are where the properties of properties are referenced within a bean:

			<bean id="classA" class="com.MyApplication.ClassA">
			    <property name="fred.bob.sammy" value="123" />
			</bean>

			Here:

				1. sammy is a property of bob who is a property of fred who is a property of ClassA.
				2. sammy is set to an inline value of 123.
				3. All properties/Beans in chain must be non-null otherwise exception is thrown.

	java.util.Properties (Auto-convert):

		- XML Configuration files may contain definitions that can be converted directly into java.util.Properties objects:

			<bean id="mappings" class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
			    <property name="properties">					<!-- Automatically interpreted as a java.util.Properties -->
				<value>
				    jdbc.driver.className=com.mysql.jdbc.Driver
				    jdbc.url=jdbc:mysql://localhost:3306/mydb
				</value>
			    </property>
			</bean>

	depends-on:

		- depends-on is an attribute of <bean/>.
		- depends-on plays a similar role to a static initialisation block which is called prior to an instantiations e.g. database driver initialisation.
		- depends-on forces a dependency to be instantiated prior to the client bean itself.
		- depends-on can force multiple dependencies to be instantiated via list delimited by whitespace, , or ;

			<bean id="classA" class="ClassA" depends-on="manager,accountDao">
			    <property name="manager" ref="manager" />
			</bean>

			<bean id="manager" class="ManagerBean" />
			<bean id="accountDao" class="com.MyApplication.jdbc.JdbcAccountDao"/>

			Here:

				1. Instants of ManagerBean and JdbcAccountDao are created and initailisaed prior to ClassA.
		
		- depends-on can be used to control both startup/initialisation order of beans and shutdown order of beans (if used in conjunction with a Singleton, where beans defined within 'depends-on' are destroyed prior to the bean itself).

	IDE Auto Complete:

		- XML Configuration files when constructed/typed within IDE typically contain auto-complete to help prevent typos, ensure that these extensions/facilities are used.

	Conversion Service:

		- XML Configuration files make use of the Conversion Service to convert string values defined 'inline' as shown into values that can be assigned to the type of the corresponded/associated property/argument.

	<idref/>

		- XML Configuration files make use of the <idref/> element which allows for typos in xml to be found during compile time rather than runtime.

			<bean id="targetBean" class="..."/>
			<bean id="clientBean" class="...">
			    <property name="targetName">
				<idref bean="targetBean"/>		//Container will validate that this bean actually exists at compile time
			    </property>
			</bean>

			NB: The above is equivalent to the following (which would only find typos during runtime):

				<bean id="targetBean" class="..." />
				<bean id="clientBean" class="...">
					<property name="targetName" value="targetBean"/>		//Typo here would only be found during runtime
				</bean>

		- <idref/> is a simple error-proof way of defining the id of another bean to form a <constructor-arg/> or <property/>.
		- <idref/> is particularly useful in the configuration of AOP interceptors in a ProxyFactoryBean bean definition in preventing misspelling of interceptor ID's.

	<ref/>

		- <ref/> is an element of <constructor-arg/> or <property/>.
		- <ref/> points to another bean as defined within the XML file using the 'id'/'name' or alias of that targetbean.
		- <ref/> contains the following attributes used to determine the scoping and validation of the targetBean:

			<bean/>:	Reference any bean in current or parent container regaredless if defined in same XML file. Most common/recommended form.

			 			<ref bean="ClassB"/>

			<parent/>:	Reference any bean in parent container regaredless if defined in sma eXML file.

			 			<ref parent="ClassB"/>

					This is mainly used when: There is a heirachy of containers and wish to wrap an existing bean in a parent container with a proxy that has the same name as the bean in the parent container.

						Parent Context:

							<bean id="accountService" class="com.something.SimpleAccountService">
							    ...
							</bean>

						Child/Current Context:

							<bean id="accountService" 						<!-- Local bean name is the same as the parent bean -->
							    class="org.springframework.aop.framework.ProxyFactoryBean">
							    <property name="target">
								<ref parent="accountService"/> 					<!-- Use/refer to the parent bean -->
							    </property>
						    	</bean>

		- <ref/> also has a 'local' attribute but is no longer supported in 4.0 bean XSD (given that it does not provide any further benefit over 'bean' attribute), recommended that all 'local' attributes updated to 'bean'.

	Inner Beans:

		- Inner Beans are anonymous beans contained and tightly coupled to the lifecycle of the enclosing bean.
		- Inner Beans are declared using a <bean/> within <constructor-arg/> or <property/>.
		- Inner Beans do not need an id/name/scope as they are anonymous and follow the scope of the enclosing bean, if specified they are ignored by container.
		- Inner Beans can not be accessed externally by other beans.
		- Inner Beans can not be injected into other beans except the enclosing bean.
		- Inner Beans are however able to be assign a destruction callback method from a custom scope e.g. request-scoped inner bean contained within a singleton bean here:

			1. Inner Bean creation is tied to enclosing bean.
			2. Inner Bean destruction callback allow it to participate in the request scopes lifecycle.

			NB: This is not common where inner beans typically just share the scope of the enclosing bean.

		- Inner Bean example:

			<bean id="enclosingBean" class="...">
			    <property name="target">							<!-- Instead of using a <ref/> to a target bean, simply define the target bean inline -->
				<bean class="com.example.Person"> 					<!-- Inner bean is anonymous and shares scope of enclosingBean -->
				    <property name="name" value="Fiona Apple"/>
				    <property name="age" value="25"/>
				</bean>
			    </property>
			</bean>

	Collections:

		- Collections can be defined, instantiated and prepopulated via inline values before being passed/injected into a constructor/setter using:

			<list/>
			<set/>
			<map/>
			<props/>

		- Collections values can be set using attributes:

			bean | ref | idref | list | set | map | props | value | null

		- Collections example:

			<bean id="classA" class="example.ClassA">
													
			    <property name="adminEmails">						<!-- Source Code: setAdminEmails(java.util.Properties) -->
				<props>
				    <prop key="administrator">administrator@example.org</prop>
				    <prop key="support">support@example.org</prop>
				    <prop key="development">development@example.org</prop>
				</props>
			    </property>

			    <property name="someList">							<!-- Source Code: setSomeList(java.util.List) -->
			    	<list>
				    <value>a list element followed by a reference</value>
				    <ref bean="myDataSource" />
			    	</list>
			    </property>
							
			    <property name="someMap">							<!-- Source Code: setSomeMap(java.util.Map) -->
			    	<map>
				    <entry key="an entry" value="just some string"/>
				    <entry key="a ref" value-ref="myDataSource"/>
			    	</map>
			    </property>
						
			    <property name="someSet">							<!-- Source Code: setSomeSet(java.util.Set) -->
			    	<set>
				    <value>just some string</value>
				    <ref bean="myDataSource" />
			    	</set>
			    </property>
			</bean>

		- Collections can be merged where the values within a child collection override the values in a parent collection.

			<beans>
			    <bean id="parent" abstract="true" class="example.ClassA">
				<property name="adminEmails">
				    <props>
					<prop key="administrator">administrator@example.com</prop>
					<prop key="support">support@example.com</prop>
				    </props>
				</property>
			    </bean>

			    <bean id="child" parent="parent">
				<property name="adminEmails">
				    <props merge="true">						<!-- merge is specified on the child collection definition -->
					<prop key="sales">sales@example.com</prop>
					<prop key="support">support@example.co.uk</prop>
				    </props>
				</property>
			    </bean>
			<beans>

			Produces the following properties:

				administrator=administrator@example.com
				sales=sales@example.com
				support=support@example.co.uk			//Override by duplicate value in child

			NB: Collection merging can only be performed on same type, differing types say list and a map will throw an exception..

		- Collections can be strongly typed where the Type Parameters is explicitly defined e.g. Map<String, Float>

			<beans>
			    <bean id="accountsService" class="x.y.ClassA">
				<property name="accounts">
				    <map>
					<entry key="one" value="9.99"/>
					<entry key="two" value="2.75"/>
					<entry key="six" value="3.99"/>
				    </map>
				</property>
			    </bean>
			</beans>

			Java Source Code:

				public class ClassA {
				    private Map<String, Float> accounts;

				    public void setAccounts(Map<String, Float> accounts) {
					this.accounts = accounts;
				    }
				}

			NB:  Spring is able to extract the metadata of the Type Parameters <String, Float> via reflection when the bean is being prepared for injection.

		- Collection full details:

			https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-properties-detailed.html#beans-collection-elements

	Empty/Null String Values

		- XML Configuration may contain inline values set to empty "" string or <null/>:

			<bean class="ClassA">
			    <property name="email" value=""/>
			</bean>

			<bean class="ClassA">
			    <property name="email">
				<null/>
			    </property>
			</bean>

			Java Source Code:

				public class ClassA {
				    public void setEmail(String s) {
					this.s = s;				//s = "" or s = null
				    }
				}

	Groovy Configuration:

		- Groovy Configuration is similar to XML Configuration expect that the configuration is contained within a *.groovy file using Springs Groovy Bean Definition DSL:

			beans {
			    dataSource(BasicDataSource) {
			    	driverClassName = "org.hsqldb.jdbcDriver"
			    	url = "jdbc:hsqldb:mem:grailsDB"
				username = "sa"
				password = ""
				settings = [mynew:"setting"]
			    }
			    sessionFactory(SessionFactory) {
				dataSource = dataSource
			    }
			    myService(MyService) {
			        nestedBean = { AnotherBean bean ->
				    dataSource = dataSource
		                }
			    }
			}

		- Groovy Configuration supports:

			1. Spring XML Namespaces.
			2. Importation of XML Configuration files vi importBean directive.
