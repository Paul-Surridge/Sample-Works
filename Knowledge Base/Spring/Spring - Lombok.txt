Spring

	Lombok:

		- Lombok is a project that is supported by many modern IDE's.
		- Lombok is a plugin that is installed into IDE's.
		- Lombok becomes a dependency within a project.
		- Lombok is a library that automatically generates and enables the simplification/removal of much common boiler plate source code.
		- Lombok generates and inserts additional code when the source code is compiled.
		- Lombok aims to make Java source code less verbose.
		- Lombok makes it easier to spot bugs and maintain the codebase.
		- Lombok takes the same amount of time to compile as non-Lombok annotated source code.
		- Lombok removes the need to explicitly type such methods as:

			1. Getters
			2. Setters
			3. equals()
			4. hashCode()
			5. toString()
			6. etc...

		- Lombok provides the following benefits:

			1. Productivity:	Increases productivity
			2. Less Code:		Write less code.
			3. Cleaner Code:	Write cleaner code.
			4. No Boilerplate:	Write less boilerplate code.
			5. Save Time:		Save significant amount of development time.

		- Lombok uses the Annotation processor API.

	Installation:

		1. IntelliJ:	File | Settings
		2. IntelliJ:	Plugins
		3. IntelliJ:	Search 'Lombok' within repositories.
		4. IntelliJ:	Install
		5. IntelliJ:	Restart
		6. Intellij:	Enable Annotation Processor API:

					1. File | Settings
					2. Build, Execution and Deployment | Compiler
					3. Annotation Processors

						1. Enable 'annotation processing'
						2. Enable 'obtain processors from project classpath'

		7. IntelliJ:	Add Lombok dependency to project.

					1. mvnrepository.com
					2. Search for Lombok
					3. Project pom.xml:		Add dependency XML extract to the project pom.xml
					4. Module pom.xml:		Add dependency XML extract to the module pom.xml e.g. core pom.xml
					5. Lombok annotations can now be used in classes within the project.

		NB: Lombok is preinstalled in later versions of IntelliJ and the above steps 1-5 is not required.

	Annotations:

		- Annotations include:

			@Getter:

				- Automatically generate the default getter() method.

					Field		Autogenerated Source Code
					_________________________________________

					boolean:	boolean isName()
					other:		otherType getName()

					NB: The field names first character is always set to upper case within the generated getter method:

						boolean validNumberRange -> boolean isValidNumberRange(){...} 		(not isvalidNumberRange).

					NB: Caution should be applied when applying the @Getter at class level for this will expose all fields, even ones with 'private' access modifier.

			@NonNull:

				- Ensures that the annotated object is not null, throwing an exception if null, preventing the need to explicitly enter the verbose below:

					if(<object> ==  null)
					  throw new NullPointerException("Object is null");

			@Setter:

				- Automatically generate the default setter() method.

					void setName(FieldType parameter)
					{...}

					NB: Caution should be applied when applying the @Setter at class level for this will expose all fields, even ones with 'private' access modifier.

			@ToString:			Generate toString() override.

			@EqualsAndHashCode:		Generate equals() and hashCode() overrides.

			@RequiredArgsConstructor:	Generate constructors with the required arguments.

			@Slf4j:				Generate the private static final field for SLF4J logger.

			@Data:

				- Class level annotation
				- Combines all:

					@Getter
					@Setter
					@ToString
					@EqualsAndHashCode
					@RequiredArgsConstructor

					NB: Constructor is not generated if it has already been declared/implemented.

	Examples:

		- @Getter/@Setter:

			Field Level:

				public class Person {

					@Getter
					@Setter
					private String firstName;

					@Getter
					@Setter
					private String lastName;
				}

			Class Level:

				@Getter
				@Setter
				public class Person {
			
					private String firstName;
					private String lastName;
				}

				NB: Caution should be applied when applying the @Getter/@Setter at class level for this will expose all fields, even ones with 'private' access modifier.

			Class Level:

				@Getter
				public class Person {
			
					private String firstName;
					private String lastName;

					@Getter(AccessLevel.NONE)		//All of the fields within the class wil be allocated getters except the string 'doNotExpose'
					private String doNotExpose
				}
































