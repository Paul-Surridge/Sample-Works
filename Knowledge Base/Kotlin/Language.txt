Kotlin

	Interoperability (Kotlin/Java):

		- Kotlin and Java are fully interoperable.
		- Kotlin and Java code can fully reference and call all entities defined in files of the other language.

			NB: Java files are only ever able to refer to what is in the bytecode as generated by the Kotlin compiler, nothing that is defined in the *.kt files themselves, this is a general rule/consideration when trying to identify what Kotlin entities are accessible from Java.  

		- Kotlin and Java both compile down to bytecode which runs within a JVM.
		- Kotlin is 'built on top' of Java, Kotlin 'interprets' its source code as Java equivalents e.g.

			"ball" in "a".."k" 		is interpreted within Java as		"a".compareTo("ball") <= 0 && "ball".compareTo("k") <= 0

		- Kotlin does not covert to Java and then to bytecode, Kotlin compiles directly to bytecode but carries out intermediate steps where necessary.
		- Kotlin is primarily an attempt to reduce the annoyances and inconveniences of Java e.g. its verbosity.

	OOP:

		- OOP in Kotlin is generally conceptually the same as in Java but with some alternate keywords and improved conveniencies:

			1. public final:		All declarations are public and final by default
			2. open:			Declare as non-final and overridable
			3. internal:			Declare as module only visibility. NB: There is no 'package-private' visibility in Kotlin
			4. override:			Overriding is now mandatory (to be researched)

			NB: The reason why public and final are the default is in order to:

				1. Balance:	Provide a balance between the needs/convenience of application developers (which commonly have members public) and libary developers (which commonly need members to be final).
				2. Smartcast:	Provide the ability to implement smartcasts given that final helps to limit the range of types a variable may be therefore enabling smartcasting.

		- OOP visibility is as follows:

					Class Member		Top-Level		JVM
					---------------------------------------------------------------------------
			public		everywhere		everywhere		public
			internal	module			module			public (with name mangling)
			protected	subclasses		n/a			protected
			private		class			file			private / package private

		- OOP 'internal'  keyword uses name mangling, for example:

			class ClassA {
			    internal fun foo(){...}							//Kotlin function defined as 'internal'
			}

			public final class ClassA {
			    public final void foo$production_sources_for_module_examples_main()		//Java equivalent generated by compiler using name mangling to generate a name that can not be accidently called from java 
			}

	Statically Typed:

		- Kotlin is statically typed.
		- Kotlin requires that all variables and expressions must be defined or return a type.
		- Kotlin does not implement dynamic variables which can be reassigned their type.
		- Kotlin implements type inference from the context of the variable initialisation or function return type.
	
	static

		- static memory does not exist in Kotlin, there is no 'static' keyword.
		- static memory is replaced/replicated by declaring/using static equivalents within:

			1. Top Level:			It is recommened by default to place all of the 'static' functionality within the top-level
			2. Objects
			3. Companion Objects

	Module:

		- Module is a container of source files, resource files, build and application settings.
		- Module is a discrete unit of functionality.
		- Module can be independently built, test and debugged (presumably handy for individual teams).
		- Module is not like a package which is a directory of related clases/interfaces/source files.
		- Module can contain multiple packages.
		- Module can be for example:

			1. IntelliJ IDEA module
			2. Mavern Project
			3. Gradle Source Set

	Concision:

		- Kotlin concision allows for highly condensed and concise source code.
		- Kotlin concision allows for a significant amount of functionality to be defined in relatively few lines of source code.
		- Kotlin concision however should not be at the expense of readability, where necessary:

			1. Do not attempt to construct highly intricate expressions on x1 line.
			2. Do attempt to break apart highly intricate x1 line expressions into suitable variables and combine as required.

	Packages:

		- Packages are orgainsed differently in Kotlin compared to Java.

			1. Class per file:	Java suggests x1 class per file, Kotlin allows for multiple classes (and top-level functions) to be defined in x1 file e.g. multiple closely related small data class's.
			2. Package name:	Package names do not need to correspond with the directory structure, package name may be any name.

		- Package names should ideally only drop the company name ('org.companyname...') from the package name but still have the package name follow the directory structure for clarity.  

	Access Modifiers:

		- Access Modifiers have x4 levels:

			public:		Accessible everywhere from all aspects of the program		Default
			protected:	Accessible from within extended classes only
			internal:	Accessible from within module
			private:	Accessible from within the class (or source file)

		- Access modifiers can be placed before:

			class/interface
			constructor
			method
			property
			property setter functions

			NB: The access modifiers of get()/set() must match or compile error is generated

		- Access modifier as assigned to:

			Class:

				[modifier] class <ClassName>
				{...}

				NB: Access modifier should come before all other modifier:	[modifier] open class <ClassName>

			Constructor:

				class <ClassName> [modifier] constructor ()
				{...}

				NB: If the constructor has an access modifier applied then 'constructor' and () must also be included

			Method:

				[modifier] fun <name>()
				{...}

		- Access modifiers should be applied as per Java where they should all be as restricted as possible:

			1. All aspects should private.
			2. If they cannot be private then set to protected.
			3. If they cannot be protected then set to internal.
			4. If they cannot be internal then let them be public.

	Top Level:

		- Top Level is a concept that exists with!in Kotlin.
		- Top Level exists in all files.
		- Top Level is the equivalent of 'static' within Java:

			1. File *.kt is to contain x1 class.
			2. File may contain members declared/defined externally to that class which are associated with that class and are accessible as static members are in java (to be researched).

		- Top Level contain the main() function which is the entry point for the program: 

			package <name>

			fun main()
			{
			    ...
			}

			fun main(args: Array<String>)		//args can be included only if needed
			{
			    ...
			}

	Conditionals:

		- Conditional as standard:

			if(condition)
			else

		- Conditional do not use the ternary operator:

			condition ? then : else

		- Conditional are all expressions which can return a value, therefore can be used as a standalone statement or in any place where an expression can be used:

			println(if (a > b) a else b)

		- Conditional can be used to assign a variable:

			val iTest = if(iNumber > 10) 100 else 200

			val iTest = if(iNumber > 10)
			{
			    ...

			    //Last statement must return a value that can be assigned to the variable
			}
			else
			{
			    ...

			    //Last statement must return a value that can be assigned to the variable
			}

		- Conditional include the 'when' keyword:

			- when is an expression, therefore can be used as a standalone statement or in any place where an expression can be used.
			- when is recommended rather than chain of if/else or switch statements.

				val s = "Hello"

				when (s)					// if/else chain or switch
				{
    				    "1" 	-> println("One")
    				    "Hello" 	-> println("Greeting")
    				    else 	-> println("Unknown")   	// Default statement  
				}

			- when has no 'fall through'.
			- when utilises Type Inference as applicable.
			- when can use any expression within the condition:

				val result = when (<expression>)		// Expression returns a value which can be checked to be equal against case's (using .equals() by the complier)
				{...}

			- when can be used to check types:

				when (pet)
				{
				    is Cat	-> pet.meow()			// smart cast accordingly
				    is Dog	-> pet.woof()			// smart cast accordingly
				}

				Here:

					1. Cat and Dog are extended classes of Pet.
					2. 'is' = instanceof
					3. Variable is declared as a Pet but contains either a Cat or Dog object.
					4. It is not necessary to cast the variable 'pet' to either a Cat or Dog before the method is invoked.
					5. Smart Cast automatically casts the variable to the corresponding type.

					NB: Smart Casts are highlighted when applied in IDE

			- when may contain both the definition of the local variable and any accompanying expression to initialise that variable within its own conditional:
			
				fun getSound(): String =
				    when (val pet = getPet())
				    {
					is Cat -> pet.meow()
					is Dog -> pet.woof()
					else -> ...
				    }

				NB: Prior to Kotlin 1.3 the variable declaration and initialisation needed to occur prior to the when statement

			- when may utilise 'in':

				fun recognise(c: Char) = when(c)
				{
				    in '0'..'9'				-> "Is a digit"
				    in 'a'..'z', in 'A'..'Z'		-> "Is a letter"
				    else				-> "Unknown"
				}

			- when used as an expression which assigns a value:

				val s = "Hello"

				val result = when (s)				// if/else chain or switch
				{
    				    "1" 	-> 10
    				    "Hello" 	-> 20
    				    else 	-> 99			   	// Default statement  
				}

				--

				enum class Color {BLUE, RED, GREEN}		// enum evaluation and assignment

				fun getDescription(colour: Colour): String =
				    when(colour)
				    {
					BLUE	-> "Cold"
					RED	-> "Hot"
					GREEN	-> "Warm"			// Default not needed given an enum will have a value
				    }
				
				--

				val temp = 18

				val description = when				// Boolean checking (when has no conditional)
				{
    				    temp < 0 	-> "very cold"
    				    temp < 10 	-> "a bit cold"
    				    temp < 20 	-> "warm"
    				    else 	-> "hot"             
				}

				--

				val s = "yes"

				val sResult = when (s)				// Multiple cases can be defined using ,
				{
    				    "y", "yes" 	-> "Correct"
    				    "n", "no" 	-> "Incorrect"
    				    else 	-> "Error"		  	// Default statement  
				}

				NB: If when is used as an expression the else branch is mandatory, unless the compiler can detect that all possible cases are covered by the branch conditions.

	
	Loops:

		- Loops within Kotlin are same as in Java, however for loops utilise 'Range' which is an object (NB: For optimisation purposes a Range object is not created when defined for primitives within a for loop):

			for(iNumber in 1..5)			// 12345	[Include Upper Bound]
			{
			    print(iNumber)
			}

			for(iNumber in 1 until 5)		// 1234		[Exclude Upper Bound]
			{
			    print(iNumber)
			}

			for(iNumber in 9 downTo 1 step 2)	// 97531
			{
			    print(iNumber)
			}

			for(c in "abc")				// abc
			{
			    print(iNumber)
			}

			for(iNumber: Int in list)		//Type inference is applicable or type can be specified explicitly
			{
			    print(iNumber)
			}

			while (iCakesEaten < 3)
			{
    			    println("Eat a cake")
    			    iCakesEaten++
			}

			do
			{
    			    println("Bake a cake")
    			    iCakesBaked++

			} while (iCakesBaked < iCakesEaten)

		- Loops are naturally applicable to Collections:

			List:

				val list = listOf("carrot", "cheese", "chocolate")

				for (cake in list)
    				    println("This is a $cake cake!")

			List: (with index)

				val list = listOf("carrot", "cheese", "chocolate")

				for ((index, element) in list.withIndex())
    				    println("$index = "$element")

			Map:

				val map = mapOf(1 to "one", 2 to "two", 3 to "three")

				for((key, value) in map)
				    println("$key = "$value")

	equals()/==/===

		- Equality in Kotlin is as follows:

						Java												Kotlin
						---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			equals()		Calls equals() between the two elements (checks reference if not overriden)			Calls equals() between the two elements (checks reference if not overriden)
			==			Checks reference equality									Calls equals() between the two elements
			===			n/a												Checks reference equality

		- Equality in Kotlin:

			val set1 = setOf(1,2,3)
			val set2 = setOf(1,2,3)

			set1 == set2		//true
			set1 === set2		//false

	Comparisons:

		- Comparisons between classes can be implemented by any class which implements .compareTo():

			a > b		a.compareTo(b) > 0
			a < b		a.compareTo(b) < 0
			a >= b		a.compareTo(b) >= 0
			a <= b		a.compareTo(b) <= 0

			NB: Kotlin compiler automatically translates any such equality comparisons to the .compareTo()

		- Comparisons between classes when compared using equality automatically uses the .equals():

			s1 == s2		//Compiler invokes .equals()

			Compiler also automatically handles nullable values, therefore it is no longer necessary to carry out a check for null before equality is applied (to be tested):

				s1 == s2	// s1.equals(s2)
				null == "abc"	// false
				null == null	// true

	Constants:

		- Constants are defined using:

			const		For primitives and String only
			@JvMField	For exposing any field (primitive or reference) as a static field assessible from Java, no accessors are created

		- Constants are implemented inline:

			const val answer = 42

			Here the identifer 'answer' is a compile-time constant whereby replaced in all locations where it is used with its value directly/inline, 'answer' also becomes a static field available from Java (just as if used @JvmField)

		- Constants when applied to properties the compiler calls the corresponding value inline:

			object SuperComputer
			{
			    const val answer = 42
			}

			println(SuperComputer.answer)		//Compiler:	System.out.println(42);

	Strings:

		String Template:

			- String Template are constructed for sending strings to standard output.
			- String Template contains a Template Expression.
			- String Template is where a variables value is replaced with string.
			- String Template is a variable prefixed with a $

				val count: Int = 2

				println("You have $count messages")
				println("You have ${count + 10} messages")		//Expressions require {}

			- String Templates are only applicable if 'inserting' a variable into an string, where you want the compiler to interpret the value of the variable and not its name.

				NB: It is still possible to just send the variable to output without $ if it is not surrounded by string:

				val iTest = 10

				println(iTest)

		Multiline Strings:

			- Multiline Strings can be implemented using """

				val s = """This is a
					multiline string"""
				|      |			//Margin/Indent

			- Multiline Strings can utilise the extension function .trimMargin() and .trimIndent() to remove the space shown above between the x2 pipes:

				val s = """This is a
					|multiline string""".trimMargin()

				val s = """This is a
					|multiline string""".trimIndent()

			- Multiline Strings do not allow for special characters but do allow String Templates.
			- Multiline Strings are useful for implementing Regular Expressions:

				val regex = """\d{2}\.\d{2}\.\d{4}"""

				regex.matches(15.02.2016)		//true
				regex.matches(15.02.16)			//false

		String/Number Conversion:

			- String/Number Conversion is implemented conveniently using extension functions of String:

				"123".toInt()		//123
				"1e-10".toDouble()	//1.0E-10

				"123".toIntOrNull()	//123
				"xx".toIntOrNull()	//null

		String Concatenation:

			- String Concatenation is implemented using + and escape sequences use \ (as in Java):

				val s1: String = "This "
				val s2: String = "is "
				val s3: String = "a string"
				val sResult = s1 + s2 + s3

				val s: String = "Say \"Hello\""		//Escape Sequences = Say "Hello"

	Arrays:

		- Arrays do not have any special built-in syntax.
		- Arrays are typically defined using the generic class Array<>:

			fun sortArray(args: Array<String>)

		- Array<> is compiled down to regular array as defined in Java but only exists as a generic class in Kotlin.
		- Arrays compile to their java equivalents:

			Kotlin		Java
			-----------------------------
			List<Int>	List<Integer>
			Array<Int>	Integer[]

			The .equals() is not overriden, therefore comparison of arrays in Kotlin is the same as in Java:

			println(arrayOf(1,2) == arrayOf(1,2))			//false, given that the reference address is checked (just as in java)
			println(arrayOf(1,2).contentsEqual(arrayOf(1,2)))	//true, given use of extension function contentEquals()

		- Arrays in Kotlin are primarily to enable interoperability with Java.
		- Arrays in Kotlin are not preferred, it is generally recommeded that List's are used (especially given that mutable lists are ArrayList<> when compiled, and that ArrayList<> have similar performance to normal arrays in Java).

	Exceptions:

		- Exceptions are generally the same as in Java, except for the following:

			1. No Checked/Unchecked:		There is no distinction between checked and unchecked exceptions.
			2. No 'throws':				There is no need for a function to specify which exception it can throw.

		- Exceptions are all unchecked, there are no checked exceptions in Kotlin, therefore it is not necessary to ever specifiy that a function 'throws' an exception:

		- Exceptions and the overall process of using exeptions leads to a lot of verbose source code.

		- Exceptions are an expression which returns a value which can be assigned to a variable:

			val percentage = 
			    if(i in 0..100) 	i
			    else 		throw IllegalArgumentException("Error")

			Here:

				1. percentage is assigned the valid number i.
				2. Or the value of an IllegalArgumentException("Error").
				3. (It is presumed that it is possible to then check the value of the percentage at a later stage)

		- Exceptions can be assigned to a variable of any type.

		- Exceptions can be ultilised within try-catch blocks:

			val i = try
			{
			    Integer.parseInt(string)	//If successful then i is assigned the numerical representation of the string
			}
			catch(e: NumberFormatException)
			{
			    return			//If return is the last statement then i is not assigned a value and (presumably) ignored altogether?
			    null			//If null is the last statement then i is assigned null (presuming it is nullable)
			}

		- Exceptions need to be used inconjunction with the @Throws annotation:

			@Throws(IOException::class)
			fun bar()
			{
			    ...

			    throw IOException
			}

			Here:

				1. If the function bar() at some point throws an IOExeption then it is necessary to append the @Throws exception (I think - to be clarified)
				2. This is due to the fact that the above is interpreted as:

					try
					{
					    obj.bar();
					}
					catch(IOException e)
					{
					    ...
					}

				3. Where this arrangement would cause the compiler to generate an error given that the try bock does not actually throw an IOException (bar() does).
				4. Consequently the annotation needs to be applied.

				(This aspect requires further research and clarity)

		- Exceptions and more specifically the throwing of an exception can be wrapped within a function:

			fun fail(): Nothing = throw IllegalArgumentException("Error has occurred, full details...")

			val n = nText.toIntegerOrNull() ?: fail()
			val d = dText.toIntegerOrNull() ?: fail()

	Inline:

		- Inlining can be applied to functions when they are declared and defined using the 'inline' keyword:

			inline fun <R> run (block: () -> R): R = block()

		- Inlining is applicable/useful when:

			fun myRun(f: () -> Unit) = f()

			fun main(...)
			{
			    val name = "Paul"

			    myRun{prinln("Hello my name is $name")}	//1 2 3

			    println("Hello my name is $name")		//4
			}

			Here:

				1. If myRun() is not defined as being inline, the compiler creates an anonymous class to store the lambda.
				2. If the lambda captures/uses variables, the anonymous object will be used to store these variables.
				3. The creation and instantiation of the anonymous class occurs with each invocation which can introduce significant overhead.
				4. This line is the effective inline equivalent if 'inline' is applied to myRun() declaration. 

		- Inlining causes the compiler to substitute the body of the function inline instead of calling the lambda if:

			1. Function accepts lambda as an argument.
			2. Function only calls this lambda within the body of the function.

			NB: The lambda must not be stored in any other location but passed as a direct argument 

		- Inlining replaces the body of the lambda as appropriate:

			fun foo(number: Int)
			{
			    val result = number.takeUnless { it > 10 }			//1

			    val result = if(!(number > 10)) number else null		//2
			}

			Here:

				1. number use the takeUnless() library function.
				2. Given that takeUnless() is inline, the equivalent function is replaced by the compiler as shown (which is the definition of takeUnless()).

		- Inlining example:

			inline fun <T> synchronized(lock: lock, action: () -> T): T
			{
			    lock.Lock()
			    try {
				return action()
			    } finally {
				lock.unlock()
			    }
			}

			fun foo(lock: Lock)
			{
			    synchronized(lock){println("Action")}
			}

			//Here the equivalent is generated inline:

			fun foo(lock: Lock)
			{
			    lock.Lock()
			    try {
				println("Action")		//Lambda body is replaced appropriately
			    } finally {
				lock.unlock()
			    }
			}

		- Inlining is only applicable to functions when called from Kotlin (not from Java), if a function is declared inline it will only be placed inline when run from the Kotlin compiler (not Java compiler).
		- Inlining should only be used with care:

			1. No Default:		Do not automatically set all of your functions inline, the compiler does inherent inlining optimisation on frequent method calls.
			2. Small Functions:	Only apply inlining to small functions for it will increase the size of the application.
			3. Stack Frames:	Inlining does not reduce/eliminate the size of stack frames i.e. the number of calls on the stack.
			4. Lambda Objects:	Inlining is good for eliminating the allocation of lambda objects e.g. a high order function which accepts a lambda and calls it repeatedly within a tight loop.

		- Inlining is applied to the majority of functions contained within the Kotlin standard library, these functions will be annotated as follows:

			@kotlin.internal.InlineOnly
			public inline fun <R> run(block: () -> R): R = block()

			This leads to:

				1. All invocations are applied inline.
				2. Given that all calls are explicitly inlined then there is no need to store/add these function(s) to the distributed *.jar, therefore these can be removed from the distributed *.jar.
				3. Given that the functions are not included in the built *.jar they will not be accessible from Java, therefore they are only accessible from Kotlin.



