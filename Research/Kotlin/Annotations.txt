Kotlin

	@JvmName:

		- @JvmName provides the ability to redefine the referred name of a class from other areas of the program.
		- @JvmName allows for a class to be referred by an alternate name other than the name of the class source file.

	@JvmOverloads:

		- @JvmOverloads when applied to a Kotlin function allows the function when called from Java to use the default arguments (otherwise arguments must be provided for all parameters):

			@JvmOverloads
			fun sum(a: Int = 10, b: Int = 20, c: Int = 30)
			{...}

			Within *.java file:

				sum(50)		//Default values 20 and 30 are used for b and c

			NB: Given the above only 4 overloads are generated by the compiler (not 2^8)

				public static final int sum(int a, int b, int c)
				public static final int sum(int a, int b)
				public static final int sum(int a)
				public static final int sum()

				This annotation should be used only when required, if you do not need to use the default arguments when called from Java then do not use the @JvmOverloads annotation but simply provide all arguments (even if they are the same as the default values).

	@JvmStatic:

		- @JvmStatic allows Objects and Companion Objects to be accessed from Java:

			class A
			{
			    companion object
			    {
				@JvmStatic fun foo() {}
				fun bar() {}
			    }
			}

			Here:

				1. @JvmStatic creates a static function that would be accessible from Java:

					A.foo();	//Compile OK
					A.bar();	//Compile Fail given that no static method is created

				2. Companion Object members are accessed from Java using the created Companion instance as a static member:

					A.Companion.foo();
					A.Companion.bar();

			object Obj
			{
			    @JvmStatic fun foo() {}
			    fun bar() {}
			}

			Here:

				1. @JvmStatic creates a static function that would be accessible from Java:

					A.foo();	//Compile OK
					A.bar();	//Compile Fail given that no static method is created

				2. Object members are accessed from Java using the created INSTANCE instance as a static member:

					A.Instance.foo();
					A.Instance.bar();

		- @JvmStatic when applied to properties the compiler calls the corresponding getter():

			object SuperComputer
			{
			    @JvmStatic
			    val answer = 42
			}

			println(SuperComputer.answer)		//Compiler:	System.out.println(SuperComputer.getAnswer());

	@JvmField:

		- @JvmField can be applied to properties to prevent accessors being created.
		- @JvmField can be applied to:

			1. Top-Level Property		Static field generated
			2. Object Property		Static field generated
			3. Class Property		Regulary field generated

		- @JvmField creates static field for top-level and object properties:

			@JvmField
			val prop = myClass()		//Top-level property

			Equivalent to:

				public static final MyClass prop = new MyClass();

		- @JvmField has following typical uses:

			1. Performance:		Improved performnce by preventing unnecessary accessors being created.
			2. Frameworks:		Frameworks which may requires certain fields to be available.

		- @JvmField when applied to properties the compiler calls the corresponding field:

			object SuperComputer
			{
			    @JvmField
			    val answer = 42
			}

			println(SuperComputer.answer)		//Compiler:	System.out.println(SuperComputer.answer);	(I preume this may be quicker than compared to @JvmStatic)
