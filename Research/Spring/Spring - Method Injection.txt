Spring

	Method Injection:

		- Method Injection is a means in which another instance of a bean can be requested from the container/ApplicationContext.
		- Method Injection involves foregoing some of the IoC, where the instantiation/management of beans and their lifecycle is not all managed by the container but by the developer/source code.

	Purpose:

		- Method Injection allows for new instances of a particular bean to be generated as/when required by the source code.
		- Method Injection removes the complete reliance and adherance to the control of the container e.g.

			1. Bean properties usually following the lifecycle of the client bean i.e. property bean is usually created/destroyed in accordance and along with the client bean e.g.

				Client Bean		Client Bean Property		Dependency Lifecycle
				------------------------------------------------------------------------------------------------------------------------------------------

				Singleton 		Singleton:			Dependency/property is created/destroyed when the client bean is created/destroyed
				non-Singleton 		non-Singleton			Dependency/property is created/destroyed when the client bean is created/destroyed

				NB: In most applications the container only has Singleton beans communicating with other Singleton beans. Singleton is the default scope for all beans.

			2. However a issue arises if the lifecycle between x2 collaborating beans differs i.e. one is a Singleton and the other is not e.g.

				1. BeanA is a singleton.
				2. BeanA needs to use a new instance of BeanB in every method.
				3. BeanA is however only created when the container is created.
				4. BeanA only creates an instance of BeanB only once when BeanA is created.
				5. BeanA will not be provided automatically by the container with a new instance of BeanB upon each method invocation.

				It is therefore necessary for a means to instruct/interact with the container and 'ask it' to generate a new instance of BeanB (via Method Injection).

			3. BeanA can be 'made aware' of the encompassing container by implementing the ApplicationContextAware interface and using .getBean("BeanB") to request/receive a new instance of BeanB during each method invocation.

		- Method Injection history: https://spring.io/blog/2004/08/06/method-injection

	applicationContext.getBean():

		- applicationContext.getBean() can be used to request a new instance of a registered bean from the container:

			import org.springframework.beans.BeansException;
			import org.springframework.context.ApplicationContext;
			import org.springframework.context.ApplicationContextAware;

			public class CommandManager implements ApplicationContextAware {

			    private ApplicationContext applicationContext;

			    public Object process(Map commandState) {							// Stateful Command-style class 'commandState' used to perform some processing
				Command command = this.applicationContext.getBean("command", Command.class);		// Request a new instance of Command from container
				command.setState(commandState);								// Set the state on the new Command instance
				return command.execute();
			    }

			    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
				this.applicationContext = applicationContext;
			    }
			}

		- applicationContext.getBean() however couples the business logic to the container, as an alternative Method Injection is a more clean means of obtaining new instances of beans.

	Lookup Method Injection:

		- Lookup Method Injection is where:

			1. Client BeanA needs a new instance of target bean BeanB.
			2. BeanA defines a method 'createBeanB':

				<protected | public> [abstract] <return-type> methodName(No-Arguments)

				In this case:

					public BeanB createBeanB()
					public abstract BeanB createBeanB()

			3. BeanA should define the 'createBeanB' method as either protected or public, concrete or abstract, have a return type of BeanB and have no arguments.

				Abstract:	Container will create a subclass and implement 'createBeanB' as required to generate and return an instance of BeanB.
				Concrete:	Container will create a subclass and override 'createBeanB' as required to generate and return an instance of BeanB.

				NB: Container uses the bytecode generated by the CGLIB Library to dynamically generate subclass.

			4. Container will now use 'createBeanB' to 'lookup', find and return an instance of BeanB.

		- Lookup Method Inject requires XML to be as follows:

			<bean id="beanB" class="com.myApplication.BeanB" scope="prototype">		//Ensure scope=prototype for new BeanB to be returned each time other wise 'singleton' for the same instance to always be returned
			    <!-- inject dependencies as normal -->
			</bean>

			<bean id="beanA" class="com.myApplication.BeanA">
			    <lookup-method name="createBeanB" bean="beanB"/>
			</bean>

			[Source code]:

				public abstract class BeanA {

				    public Object process() {
					BeanB = createBeanB();
					return BeanB.execute();
				    }

				    public abstract BeanB createBeanB();		//1

				    @Lookup("beanB")					//2
				    public abstract BeanB createBeanB();

				    @Lookup						//3
				    public abstract BeanB createBeanB();
				}

				Here:
					(1)
						1. Container creates a subclass of BeanA and implements abstract method 'createBeanB'.
						2. Container uses that extended class to instantiate and return a new instance of BeanB each time createBeanB() is called.

					(2)
						1. Container uses the @Lookup annotation with attribute corresponding to the bean ID as defined in the XML.
						2. Container injects a new instance of BeanB as required.

					(3)
						1. Container uses the @Lookup annotation inconjunction with the return type 'BeanB' to find the class definition within the container bean register.
						2. Container injects a new instance of BeanB as required.

					NB:
						- Annotated lookup methods should contain a stub implementation.
						- This is for them to be compatible with Strings component scanning rules where abstract classes get ignored.
						- This however does not apply explicitly registered/imported bean classes.

		- Lookup Method Injection rules:

			1. final:		BeanA nor createBeanB() can be final (for the container needs to extend them as described).
			2. @Bean Methods:	Container is not in fully charge of bean creation therefore cannot create a runtime generated subclass on the fly.

		- Lookup Method Injection has the following alternative means of accessing/injecting beans of differing scopes:

			1. ObjectFactory/Provider Injection Points:		https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-other-injection
			2. ServiceLocatorFactoryBean:				Found in org.springframework.beans.factory.config package.
			3. Arbitrary Method Replacement:			https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection.html#beans-factory-arbitrary-method-replacement
















































